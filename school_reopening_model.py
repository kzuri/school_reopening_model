# -*- coding: utf-8 -*-
"""Markov_simulation_until_ContactMatrix.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LGWZx3ufYsxbdmKKlBS7wstAHmhTqUfH
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import random
import math


# Defining Parameters

#################### PARAMETERS #####################

### STATE A ###

n_students = 1000
n_teach = 200
n_nonteach = 100

n_total = n_students + n_teach + n_nonteach

student_prop = n_students / n_total
teach_prop = n_teach / n_total
nonteach_prop = n_nonteach / n_total

s_age_lower = 18
s_age_upper = 21

avg_batch_size = 230

t_age_lower = 30
t_age_upper = 45

nt_age_lower = 30
nt_age_upper = 50

# residential campus
outside_prop = 0  # changes according to groups
inside_prop = 1 - outside_prop

### STATE B ###
quarantine_prop = 0.1
quarantine_size = (n_students + n_teach + n_nonteach) * quarantine_prop
batches = 100  # total (students+teacher+...)
daily_outside_pop = 0  # Pending...

# 5% infected --india mean i.e 65/1300 infected

testing_period = 14  # function of batches
testing_positive_prop = ""  # function of sensitivity and specificity
# probability of testing if symptoms arises

### STATE C ###

kit_sensitivity = 0.6  # > 0.4 -- < 0.8    #upper and lower limit to be consider
kit_specificity = 0.98  # > 0.95 -- < 0.99

fnr = 1 - kit_sensitivity
fpr = 1 - kit_specificity

### STATE D ###

social_mixing_matrix = ""  # From csv
contact_duration = ""

### random seed ###
seed = 2020

# generate dictionary
def dict_generate(n_total):
    pdict = {}
    for i in range(n_total):
        pdict[i + 1] = {}

    return pdict


# Age distribution
def age_distribute(
    n_students,
    s_age_lower,
    s_age_upper,
    avg_batch_size,
    n_teach,
    t_age_lower,
    t_age_upper,
    n_nonteach,
    nt_age_lower,
    nt_age_upper,
    n_total,
    seed,
):
    random.seed(seed)

    pdict = dict_generate(n_total)

    category = ["Students", "Teaching", "Non teaching"]

    age_count = {"Students": {}, "Teaching": 0, "Non teaching": 0}

    batch = n_students // avg_batch_size

    limit = {"Students": {}, "Teaching": n_teach, "Non teaching": n_nonteach}

    limit["Students"]["Batch 1"] = avg_batch_size + n_students % avg_batch_size
    age_count["Students"]["Batch 1"] = 0

    for i in range(batch - 1):
        limit["Students"]["Batch " + str(i + 2)] = avg_batch_size
        age_count["Students"]["Batch " + str(i + 2)] = 0

    # print("limit : ",limit)
    # print("Age dict: ",age_count)

    stu_age = list(range(s_age_lower, s_age_upper + 1))

    for i in pdict.keys():
        temp = []
        for cat in category:
            if cat == "Students":
                for key in age_count[cat].keys():
                    if age_count[cat][key] >= limit["Students"][key]:
                        temp.append(key)
                        # del age_count[cat][key]
                        # del stu_age[int(key[-1])-1]

            elif age_count[cat] >= limit[cat]:
                del category[category.index(cat)]

        for j in temp:
            # print("before : ",j,stu_age,int(j[-1])+18-1)
            del age_count["Students"][j]
            stu_age.remove(int(j[-1]) + 17)
            # print(j,stu_age)

        pick = random.choice(category)

        pdict[i]["categ"] = pick
        if pick == "Students":
            age = random.choice(stu_age)
            # rint(pick,age)
            pdict[i]["Age"] = age
            age_count[pick]["Batch " + str(age - s_age_lower + 1)] += 1

        elif pick == "Teaching":
            age = random.randint(t_age_lower, t_age_upper)
            # print(pick,age)
            pdict[i]["Age"] = age
            age_count[pick] += 1

        elif pick == "Non teaching":
            age = random.randint(nt_age_lower, nt_age_upper)
            # print(pick,age)
            pdict[i]["Age"] = age
            age_count[pick] += 1

    return pdict


def infected(n_total):
    pdict = age_distribute(
        n_students,
        s_age_lower,
        s_age_upper,
        avg_batch_size,
        n_teach,
        t_age_lower,
        t_age_upper,
        n_nonteach,
        nt_age_lower,
        nt_age_upper,
        n_total,
        seed,
    )

    for k in pdict.keys():
        pdict[k]["Infected"] = 0

    rate = n_total // 20

    for i in random.sample(list(pdict.keys()), rate):
        pdict[i]["Infected"] = 1

    return pdict


def trunc_gauss(mean, sigma, lower, upper):
    a = random.gauss(mean, sigma)

    while (lower <= a <= upper) == False:
        a = random.gauss(mean, sigma)

    return int(a)


def infection_day():

    mean = 6
    sigma = 2
    lower = 1
    upper = 15

    pdict = infected(n_total)

    infect_list = []

    for k in pdict.keys():
        if pdict[k]["Infected"] == 1:
            infect_list.append(k)
            day = trunc_gauss(mean, sigma, lower, upper)

            pdict[k]["day of infection"] = day

            if 3 <= day <= 10:
                pdict[k]["danger"] = "s"  # Danger flags -s Super -a Medium -b Low
            else:
                pdict[k]["danger"] = "a"

            pdict[k]["Status"] = 0  # Status = 1 --> Symptomatic ; 0 --> Asymptomatic

        else:
            pdict[k]["day of infection"] = np.nan
            pdict[k]["danger"] = "b"
            pdict[k]["Status"] = np.nan
    return pdict, infect_list


def symptomatic(n_total):
    pdict, infect_list = infection_day()

    rate = 0.6  # 60% symptomatic, 40% asymptomatic

    for i in random.sample(infect_list, int(rate * len(infect_list))):
        pdict[i]["Status"] = 1

    return pdict, infect_list


def Diff(li1, li2):
    li_dif = [i for i in li1 + li2 if i not in li1 or i not in li2]
    return li_dif


def test_kit(kit_specificity, kit_sensitivity, fnr, fpr):
    pdict, infect_list = symptomatic(n_total)

    for k in pdict.keys():
        pdict[k]["ContactMatrix"] = 0

    for i in random.sample(infect_list, int(fnr * len(infect_list))):
        pdict[i]["ContactMatrix"] = 1

    uninfect_list = Diff(list(pdict.keys()), infect_list)
    # print(len(uninfect_list))

    fpr_uninfected = random.sample(uninfect_list, int(fpr * len(uninfect_list)))
    # print(len(fpr_uninfected))

    remain_uninfect_list = Diff(uninfect_list, fpr_uninfected)
    # print(len(remain_uninfect_list))

    for i in remain_uninfect_list:
        pdict[i]["ContactMatrix"] = 1

    # print(int(fnr * len(infect_list)))
    return pdict


pdict = test_kit(kit_specificity, kit_sensitivity, fnr, fpr)

ptable = pd.DataFrame.from_dict(pdict).T

ptable.to_csv("UntilContactMatrix.csv")

print("Total no. of people entering contact matrix state : ", ptable["ContactMatrix"].sum())


# -*- coding: utf-8 -*-
"""Networkx model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Voss17Kf50Ls4Qu8pfpq2qpKB8vbgqX8

Installing missing libraries
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install EoN
# !pip install pyvis

"""Defining libraries to be used"""

import networkx as nx
import EoN
import matplotlib.pyplot as plt
import pandas as pd
import random as random
from itertools import combinations
import copy

"""# Data pre-processing"""

Contact_school = pd.read_excel(
    "https://github.com/kzuri/school_reopening_model/blob/main/ContactMatricesPremetAl.xlsx?raw=true",
    sheet_name="School Contacts",engine='openpyxl'
)
Contact_res = pd.read_excel(
    "https://github.com/kzuri/school_reopening_model/blob/main/ContactMatricesPremetAl.xlsx?raw=true",
    sheet_name="Residential Contacts",engine='openpyxl'
)  # import contact matrix

ptable = ptable[ptable["ContactMatrix"] == 1]
pdict = ptable.T.to_dict()

# Underlying contact network- will make edges on random with 6 different people
# depend on their age and average number of contacts they have from PremetAl Matrix


def getUserLists(UserType):
    UserList = ptable[ptable["categ"] == UserType].index.to_list()
    return UserList


# Each student interacts with (5-10) other students, Student <-> non teaching (3-4)
# Teacher to Teacher (3) , Student <-> Teacher = 3-4 students for every teacher, Non-Taching <-> Non Teaching = (6),
# Teaching <-> Non Teaching = For every teacher 3-4 Non Teaching.

stud_list = getUserLists("Students")
teach_list = getUserLists("Teaching")
non_teach_list = getUserLists("Non teaching")
stud_age = list(set(ptable[ptable["categ"] == "Students"]["Age"]))

Student_num = len(stud_list)
Teacher_num = len(teach_list)
Non_teach_num = len(non_teach_list)

"""# Conditions for edge formation"""


def create_edges(list1, list2, multiplier):  ## for every member in list1 there will be "multiplier" number of edges in list 2
    edges = []

    total_interactions = multiplier * len(list1)
    while total_interactions > 0:
        node1 = random.choice(list1)
        node2 = random.choice(list2)
        if node1 != node2:
            edges.append((node1, node2))
            total_interactions = total_interactions - 1

    return edges


def divide_age_grp(pdict, stud_age, stud_list):
    age_grp = {}

    for i in stud_age:
        age_grp[i] = []

    for i in stud_list:
        age_grp[pdict[i]["Age"]].append(i)

    return age_grp


def get_index_combination(combination, source_list):
    # combination_list = list(combination)
    a, b = zip(*combination)
    a = list(a)
    sl = set(a)
    return [a.index(i) for i in sl]


def intraclass_generate(ncluster, prob_interaction=0):
    connection_grp = {}
    connection = []
    age_grp = divide_age_grp(pdict, stud_age, stud_list)

    for k in age_grp.keys():
        combination = combinations(age_grp[k], 2)
        combination1 = copy.copy(combination)

        idx_list = get_index_combination(combination, age_grp[k])
        combination_list = list(combination1)

        for i, idx in enumerate(idx_list[:-1]):
            if idx_list[i + 1] - idx_list[i] < ncluster + 1:
                connection += combination_list[idx_list[i] : idx_list[i + 1]]
            else:
                for j in random.sample(
                    combination_list[idx_list[i] : idx_list[i + 1]],
                    random.randint(ncluster - 1, ncluster + 1),
                ):
                    connection.append(j)

    return connection


def interclass_generate():
    connection_list = []

    age_grp = divide_age_grp(pdict, stud_age, stud_list)
    combination = combinations(age_grp.keys(), 2)
    for i in combination:
        connection_list += create_edges(age_grp[i[0]], age_grp[i[1]], 1)

    return connection_list


"""Combining result from above helper functions"""

edges_list = []
edges_list += create_edges(teach_list, teach_list, 3)
edges_list += create_edges(non_teach_list, non_teach_list, 6)
edges_list += create_edges(teach_list, non_teach_list, 3)
edges_list += create_edges(teach_list, stud_list, 3)  # For every teacher 3 students
edges_list += create_edges(stud_list, non_teach_list, 3)

# Age wise students to be added into classes & their interactions to be appended
edges_list += intraclass_generate(ncluster=5)
edges_list += interclass_generate()
edges_list = list(set(edges_list))

print(
    "The number of Edges formed are ",
    len(edges_list),
    "and one of the sample is ",
    edges_list[0],
)

"""# Initializing  `Contacts` network"""

categ_contact_matrix = [[10.0, 6.0, 0.8],  # s-s s-t s-nt
                        [6.0, 8.0, 2.0],  # t-s t-t t-nt
                        [0.8, 2.0, 4.0],]  # nt-s nt-t nt-nt

age_contact_matrix = Contact_school.to_numpy()


def add_nodes(pdict):
    node = []

    for k in pdict.keys():
        node.append((k,{"categ": pdict[k]["categ"],
                        "Age": pdict[k]["Age"],
                        "Infected": pdict[k]["Infected"],
                        "DayOfInfection": pdict[k]["day of infection"],
                        "Status": pdict[k]["Status"],
                        "risk_coeff": pdict[k]["danger"]},))

    return node


def edge_weights(contact_matrix_categ, contact_matrix_age, pdict, edge, mode):  # According to category
    i = edge[0]
    j = edge[1]

    categ_index = {"Students": 0, "Teaching": 1, "Non teaching": 2}

    if mode == "category":
        return contact_matrix_categ[categ_index[pdict[i]["categ"]]][categ_index[pdict[i]["categ"]]]
    elif mode == "age":
        return contact_matrix_age[pdict[i]["Age"] // 8][pdict[j]["Age"] // 8]
    else:
        raise NameError(mode)


def edge_weights_premetal(contact_matrix, pdict, edge):  # According to age
    i = edge[0]
    j = edge[1]
    return contact_matrix[pdict[i]["Age"] // 8][pdict[j]["Age"] // 8]


Contacts = nx.Graph()

Node_info = add_nodes(pdict)
Contacts.add_nodes_from(Node_info)

# Contacts graph will basically consist of the edge weight which would be the number of connects a node can make according to the age and also whether or not it is infected
Contacts.add_edges_from(edges_list)  

# transmission_weight will come from contact_matrix and hence we wont need above weights but this will depend on age

# Uncomment below for category one

edge_attribute_dict = {edge: edge_weights(categ_contact_matrix, 
                                          age_contact_matrix, 
                                          pdict, 
                                          edge, 
                                          mode="age")  # mode : age,category
                        for edge in Contacts.edges()}

nx.set_edge_attributes(Contacts, values=edge_attribute_dict, name="transmission_weight")

print("Contacts network done!")
'''
"""# EoN magic"""

#Graph which is not induced, for example: E -> I, I -> R 
H=nx.DiGraph()
H.add_node('S') #Susceptible
H.add_edge('E', 'I', rate = 0.29) #we can also have a weight label to add higher chances of people moving from E->I depending on duration- not needed now, need this rate, could be constant, need lit
H.add_edge('I', 'R', rate = 0.95) #need recovery rate for India/TN

#Induced Graph according to transmission rates or probability of transitions
J = nx.DiGraph()
for nodes in Contacts.nodes():
  if Contacts.nodes[nodes]["Status"] == "Asymptomatic":
    J.add_edge(('I', 'S'), ('I', 'E'), rate = 0.225, weight_label='transmission_weight')
  else:
    J.add_edge(('I', 'S'), ('I', 'E'), rate = 0.9, weight_label='transmission_weight') #Input - Transmission rate (beta)

IC={}   #initial status
for nodes in Contacts.nodes():
  if Contacts.nodes[nodes]["Infected"]== 1:
    IC[nodes]='I'
  else:
    IC[nodes]= 'S'

return_statuses = ('S', 'E', 'I', 'R')


#sim=EoN.Gillespie_SIR(Contacts,1,1,return_full_data=True)
t, S, E, I, R = EoN.Gillespie_simple_contagion(Contacts, 
                                               H, J, IC, 
                                               return_statuses,
                                               tmax = float('Inf'))

plt.semilogy(t, S, label = 'Susceptible')
plt.semilogy(t, E, label = 'Exposed')
plt.semilogy(t, I, label = 'Infected')
plt.semilogy(t, R, label = 'Recovered')
plt.legend()
#sim.display(time=1)
plt.show()

#T = sim.transmission_tree() #A networkx DiGraph with the transmission tree
#Tpos = EoN.hierarchy_pos(T) #pos for a networkx plot
#fig = plt.figure(figsize = (8,5))
#ax = fig.add_subplot(111)
#nx.draw(T, Tpos, ax=ax, node_size = 15, with_labels=True)
plt.show()
'''
